# Copyright (c) 2013 Spotify AB
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.
"""
Extension for generating Avro schemas from PySchema Record classes

Usage:

>>> class MyRecord(pyschema.Record):
>>>     foo = Text()
>>>     bar = Integer()
>>>
>>> [pyschema.contrib.avro.]get_schema_string(MyRecord)

'{"fields": [{"type": "string", "name": "foo"},
{"type": "long", "name": "bar"}],
"type": "record", "name": "MyRecord"}'

"""
from pyschema import core
from pyschema.types import Field, Boolean, Integer, Float, Bytes, Text, Enum, List
import simplejson as json


Boolean._avro_type = "boolean"
Integer._avro_type = "long"
Float._avro_type = "double"
Bytes._avro_type = "bytes"
Text._avro_type = "string"
Enum._avro_type = "ENUM"  # this is the avro 'type name' of all enums generated by pyschema
List._avro_type = "array"


@Field.mixin
def _avro_spec(self):
    return {"type": [self._avro_type, "null"]}


@Field.mixin
def avro_dump(self, o):
    if o is None:
        return None
    else:
        return {self._avro_type: self.dump(o)}


@Field.mixin
def avro_load(self, o):
    if o is None:
        return None
    else:
        return self.load(o[self._avro_type])


@List.mixin
def _avro_spec(self):
    field_avro_type = self.field_type._avro_type
    return {
        "type": [
            {
                "type": "array",
                "items": field_avro_type
            },
            "null"
        ]
    }


@Enum.mixin
def _avro_spec(self):
    return {
        "type": [
            {
                "type": "enum",
                "name": self._avro_type,
                "symbols": list(self.values)
            },
            "null"
        ]
    }


def get_schema_dict(record):
    avro_record = {
        "type": "record",
        "name": record._record_name,
    }
    avro_fields = []
    for field_name, field_type in record._schema:
        field_spec = {
            "name": field_name,
        }
        field_spec.update(field_type._avro_spec())
        avro_fields.append(field_spec)

    avro_record["fields"] = avro_fields
    return avro_record


def get_schema_string(record):
    return json.dumps(get_schema_dict(record))


def to_json_compatible(record):
    """ WARNING: because dictionaries aren't ordered, the output of this will
    not necessarily be compatible with json avro-readers that assume ordered fields

    Use OrderedPySchemaJsonEncoder to encode Records to avro json
    """
    d = {}
    for fname, f in record._schema:
        val = getattr(record, fname)
        d[fname] = f.avro_dump(val)
    return d


class OrderedPySchemaJsonEncoder(json.JSONEncoder):
    """ Custom JSONEncoder for preserving field order
    in serialized json strings (from schema definition)

    This is required by some configurations of the java Avro JsonDecoder
    """
    def encode_record(self, record):
        string_parts = []
        for name, fieldtype in record._schema:
            value = getattr(record, name)
            string_parts.append(''.join((
                self.encode(name),
                self.key_separator,
                self.encode(fieldtype.avro_dump(value))
            )))
        return ''.join((
            '{',
            self.item_separator.join(string_parts),
            '}'
        ))

    def encode(self, x):
        if isinstance(x, core.Record):
            return self.encode_record(x)
        return super(OrderedPySchemaJsonEncoder, self).encode(x)


ordered_json_encoder = OrderedPySchemaJsonEncoder()


def dumps(record):
    return ordered_json_encoder.encode(record)


def from_json_compatible(record_class, dct):
    field_values = {}
    schema = record_class._schema
    for field_name, field_type in schema:
        if field_name in dct:
            field_values[field_name] = field_type.avro_load(dct[field_name])

    return record_class(**field_values)


def loads(s, record_store=None, record_class=None):
    return core.loads(s, record_store, record_class, from_json_compatible)
