import copy
from pyschema import types
import pyschema
import os
from collections import defaultdict

DEFAULT_INDENT = " " * 4


class SourceGenerationError(Exception):
    pass


def to_python_source(classes, indent=DEFAULT_INDENT):
    """Convert a set of pyschemas to executable python source code

    Currently supports all built-in types for basic usage.

    Notably not supported:
    * Maintaining class hierarchy
    * Methods, properties and non-field attributes
    * SELF-references
    """
    return header_source() + "\n" + classes_source(classes, indent)


def to_python_package(classes, target_folder, indent=DEFAULT_INDENT):
    default_namespace = '__init__'
    class_graph = CachedGraphTraverser()

    all_classes = set(classes)
    for c in classes:
        referenced_schemas = class_graph.find_descendents(c)
        all_classes |= set(referenced_schemas)

    namespace_cluster = defaultdict(set)
    for c in all_classes:
        try:
            namespace = c._namespace
        except AttributeError:
            namespace = default_namespace
        namespace_cluster[namespace].add(c)

    print namespace_cluster

    for namespace, classes in namespace_cluster.iteritems():
        key = namespace.split('.')
        output_file = os.path.join(target_folder, *key) + '.py'
        output_dir = os.path.join(target_folder, os.path.dirname(output_file))
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        with open(output_file, 'w') as out_fn:
            out_fn.write(to_python_source(list(classes)))
            #TODO, need to make sure we don't parse references here, need to call a simpler version


def classes_source(classes, indent=DEFAULT_INDENT):
    all_classes = set(classes)
    class_graph = CachedGraphTraverser()
    for c in classes:
        referenced_schemas = class_graph.find_descendents(c)
        all_classes |= set(referenced_schemas)

    ordered = class_graph.get_reference_ordered_schemas(all_classes)
    return "\n\n".join([_class_source(c, indent) for c in ordered])


def header_source():
    """Get the required header for generated source"""
    return (
        "import pyschema\n"
        "from pyschema.types import *\n"
        "from pyschema.core import NO_DEFAULT\n"
    )


def _class_source(schema, indent):
    """Generate Python source code for one specific class

    Doesn't include or take into account any dependencies between record types
    """

    def_pattern = (
        "class {class_name}(pyschema.Record):\n"
        "{indent}# WARNING: This class was generated by pyschema.to_python_source\n"
        "{indent}# there is a risk that any modification made to this class will be overwritten\n"
        "{optional_namespace_def}"
        "{field_defs}\n"
    )
    if hasattr(schema, '_namespace'):
        optional_namespace_def = "{indent}_namespace = {namespace!r}\n".format(
            namespace=schema._namespace, indent=indent)
    else:
        optional_namespace_def = ""

    field_defs = [
        "{indent}{field_name} = {field!r}".format(field_name=field_name, field=field, indent=indent)
        for field_name, field in schema._fields.iteritems()
    ]
    if not field_defs:
        field_defs = ["{indent}pass".format(indent=indent)]

    return def_pattern.format(
        class_name=schema._schema_name,
        optional_namespace_def=optional_namespace_def,
        field_defs="\n".join(field_defs),
        indent=indent
    )


class CachedGraphTraverser(object):
    def __init__(self):
        self.descendents = {}
        self.started = set()

    def find_descendents(self, a):
        if a in self.descendents:
            # fetch from cache
            return self.descendents[a]
        self.started.add(a)
        subs = set()
        if pyschema.ispyschema(a):
            for _, field in a._fields.iteritems():
                subs |= self.find_descendents(field)
            self.descendents[a] = subs
        elif isinstance(a, types.List):
            subs |= self.find_descendents(a.field_type)
        elif isinstance(a, types.Map):
            subs |= self.find_descendents(a.value_type)
        elif isinstance(a, types.SubRecord):
            subs.add(a._schema)
            if a not in self.started:  # otherwise there is a circular reference
                subs |= self.find_descendents(a._schema)
        self.started.remove(a)
        return subs

    def get_reference_ordered_schemas(self, schema_set):
        for schema in schema_set:
            self.find_descendents(schema)
        descendents = copy.deepcopy(self.descendents)  # a working copy

        ordered_output = []
        while descendents:
            leaves = []
            for root, referenced in descendents.iteritems():
                if len(referenced) == 0:
                    leaves.append(root)
            if not leaves:
                raise SourceGenerationError("Circular reference in input schemas, aborting")
            ordered_output += leaves
            for leaf in leaves:
                # remove all leaves
                descendents.pop(leaf)
                for root, referenced in descendents.iteritems():
                    if leaf in referenced:
                        referenced.remove(leaf)
        return ordered_output
