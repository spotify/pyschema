import copy
from pyschema import types
import pyschema
import os
from collections import defaultdict

DEFAULT_INDENT = " " * 4


class SourceGenerationError(Exception):
    pass


def to_python_source(classes, indent=DEFAULT_INDENT):
    """Convert a set of pyschemas to executable python source code

    Currently supports all built-in types for basic usage.

    Notably not supported:
    * Maintaining class hierarchy
    * Methods, properties and non-field attributes
    * SELF-references
    """
    return header_source() + "\n" + classes_source(classes, indent)


class PackageBuilder(object):
    def __init__(self, target_folder, parent_package, indent=DEFAULT_INDENT):
        self.target_folder = target_folder
        self.parent_package = parent_package
        self.indent = indent

    def get_namespace(self, schema):
        try:
            namespace = schema._namespace
        except AttributeError:
            namespace = None
        return namespace

    def get_namespace_clusters(self, all_classes):
        namespace_cluster = defaultdict(set)
        for c in all_classes:
            namespace = self.get_namespace(c)
            namespace_cluster[namespace].add(c)
        return namespace_cluster

    def format_definitions(self, classes):
        return "\n\n".join([_class_source(c, self.indent) for c in classes])

    def write_namespace_file(self, namespace, module_code):
        if namespace is None:
            key = ['__init__']
        else:
            key = namespace.split('.')
        output_file = os.path.join(self.target_folder, *key) + '.py'
        output_dir = os.path.join(self.target_folder, os.path.dirname(output_file))
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        with open(output_file, 'w') as out_fn:
            out_fn.write(module_code)

    def format_imports(self, imported_classes):
        if not imported_classes:
            return "\n"
        imported_namespaces = self.get_namespace_clusters(imported_classes)
        lines = []
        for namespace, schemas in imported_namespaces.iteritems():
            if self.parent_package:
                if namespace:
                    module = "{}.{}".format(self.parent_package, namespace)
                else:
                    module = self.parent_package
            else:
                if not namespace:
                    module = "."
                else:
                    module = namespace
            class_part = ", ".join(s.__name__ for s in schemas)
            lines.append("from {} import {}".format(module, class_part))
        return "\n".join(lines) + "\n\n"

    def from_classes_with_refs(self, classes):
        class_graph = CachedGraphTraverser()

        all_classes = set(classes)
        for c in classes:
            referenced_schemas = class_graph.find_descendents(c)
            all_classes |= set(referenced_schemas)

        namespace_cluster = self.get_namespace_clusters(all_classes)

        ordered_schemas = class_graph.get_reference_ordered_schemas(all_classes)

        for namespace, classes in namespace_cluster.iteritems():
            inlined_classes = [c for c in ordered_schemas if c in classes]
            imported_classes = set()

            for inlined in inlined_classes:
                all_referenced = class_graph.find_descendents(inlined)
                imported_classes |= set([c for c in all_referenced if c not in inlined_classes])

            module_code = (
                header_source() +
                self.format_imports(imported_classes) +
                self.format_definitions(inlined_classes)
            )
            self.write_namespace_file(namespace, module_code)


def to_python_package(classes, target_folder, parent_package=None, indent=DEFAULT_INDENT):
    PackageBuilder(target_folder, parent_package, indent).from_classes_with_refs(classes)


def classes_source(classes, indent=DEFAULT_INDENT):
    all_classes = set(classes)
    class_graph = CachedGraphTraverser()
    for c in classes:
        referenced_schemas = class_graph.find_descendents(c)
        all_classes |= set(referenced_schemas)

    ordered = class_graph.get_reference_ordered_schemas(all_classes)
    return "\n\n".join([_class_source(c, indent) for c in ordered])


def header_source():
    """Get the required header for generated source"""
    return (
        "import pyschema\n"
        "from pyschema.types import *\n"
        "from pyschema.core import NO_DEFAULT\n"
    )


def _class_source(schema, indent):
    """Generate Python source code for one specific class

    Doesn't include or take into account any dependencies between record types
    """

    def_pattern = (
        "class {class_name}(pyschema.Record):\n"
        "{indent}# WARNING: This class was generated by pyschema.to_python_source\n"
        "{indent}# there is a risk that any modification made to this class will be overwritten\n"
        "{optional_namespace_def}"
        "{field_defs}\n"
    )
    if hasattr(schema, '_namespace'):
        optional_namespace_def = "{indent}_namespace = {namespace!r}\n".format(
            namespace=schema._namespace, indent=indent)
    else:
        optional_namespace_def = ""

    field_defs = [
        "{indent}{field_name} = {field!r}".format(field_name=field_name, field=field, indent=indent)
        for field_name, field in schema._fields.iteritems()
    ]
    if not field_defs:
        field_defs = ["{indent}pass".format(indent=indent)]

    return def_pattern.format(
        class_name=schema._schema_name,
        optional_namespace_def=optional_namespace_def,
        field_defs="\n".join(field_defs),
        indent=indent
    )


class CachedGraphTraverser(object):
    def __init__(self):
        self.descendents = {}
        self.started = set()

    def find_descendents(self, a):
        if a in self.descendents:
            # fetch from cache
            return self.descendents[a]
        self.started.add(a)
        subs = set()
        if pyschema.ispyschema(a):
            for _, field in a._fields.iteritems():
                subs |= self.find_descendents(field)
            self.descendents[a] = subs
        elif isinstance(a, types.List):
            subs |= self.find_descendents(a.field_type)
        elif isinstance(a, types.Map):
            subs |= self.find_descendents(a.value_type)
        elif isinstance(a, types.SubRecord):
            subs.add(a._schema)
            if a not in self.started:  # otherwise there is a circular reference
                subs |= self.find_descendents(a._schema)
        self.started.remove(a)
        return subs

    def get_reference_ordered_schemas(self, schema_set):
        for schema in schema_set:
            self.find_descendents(schema)
        descendents = copy.deepcopy(self.descendents)  # a working copy

        ordered_output = []
        while descendents:
            leaves = []
            for root, referenced in descendents.iteritems():
                if len(referenced) == 0:
                    leaves.append(root)
            if not leaves:
                raise SourceGenerationError("Circular reference in input schemas, aborting")
            ordered_output += leaves
            for leaf in leaves:
                # remove all leaves
                descendents.pop(leaf)
                for root, referenced in descendents.iteritems():
                    if leaf in referenced:
                        referenced.remove(leaf)
        return ordered_output
